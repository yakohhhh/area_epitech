#!/bin/bash

# üöÄ AREA - Script Principal de D√©veloppement
# Lance automatiquement Backend, Frontend Web et Mobile
# Usage: ./start-all.sh [mode]
# Mo        # Mode automatique si variable d'environnement AUTO_KILL_PORTS est d√©finie ou argument --auto
        if [[ "$AUTO_MODE" == "true" ]] || [[ "$AUTO_KILL_PORTS" == "true" ]]; then
            print_status "üßπ Lib√©ration automatique des ports..."
            # Essayer sans sudo d'abord
            pkill -f "npm run" 2>/dev/null || true
            fuser -k 5001/tcp 3000/tcp 5175/tcp 2>/dev/null || sudo fuser -k 5001/tcp 3000/tcp 5175/tcp 2>/dev/null || true
            sleep 2
            print_success "‚úì Ports lib√©r√©s automatiquement" (d√©faut), docker, clean

set -e

# Couleurs pour l'affichage
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Emojis pour les services
BACKEND_EMOJI="‚ö°"
FRONTEND_EMOJI="üåê"
MOBILE_EMOJI="üì±"
SUCCESS_EMOJI="‚úÖ"
ERROR_EMOJI="‚ùå"
INFO_EMOJI="‚ÑπÔ∏è"

print_header() {
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë                    üöÄ AREA DEV LAUNCHER                      ‚ïë${NC}"
    echo -e "${CYAN}‚ïë              Backend + Frontend + Mobile                     ‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
}

print_status() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }
print_service() { echo -e "${PURPLE}[SERVICE]${NC} $1"; }

# Variables globales
BACKEND_PID=""
FRONTEND_PID=""
MOBILE_PID=""
MODE="dev"
AUTO_MODE=false

# Parse des arguments
for arg in "$@"; do
    case $arg in
        --auto)
            AUTO_MODE=true
            ;;
        clean|docker)
            MODE=$arg
            ;;
        *)
            if [[ -z "$MODE" || "$MODE" == "dev" ]]; then
                MODE=$arg
            fi
            ;;
    esac
done

# Fonction de nettoyage des processus
cleanup() {
    echo ""
    print_warning "üõë Arr√™t des services en cours..."
    
    if [ ! -z "$BACKEND_PID" ] && kill -0 "$BACKEND_PID" 2>/dev/null; then
        print_status "${BACKEND_EMOJI} Arr√™t du backend (PID: $BACKEND_PID)"
        kill -TERM "$BACKEND_PID" 2>/dev/null || true
    fi
    
    if [ ! -z "$FRONTEND_PID" ] && kill -0 "$FRONTEND_PID" 2>/dev/null; then
        print_status "${FRONTEND_EMOJI} Arr√™t du frontend (PID: $FRONTEND_PID)"
        kill -TERM "$FRONTEND_PID" 2>/dev/null || true
    fi
    
    if [ ! -z "$MOBILE_PID" ] && kill -0 "$MOBILE_PID" 2>/dev/null; then
        print_status "${MOBILE_EMOJI} Arr√™t du mobile (PID: $MOBILE_PID)"
        kill -TERM "$MOBILE_PID" 2>/dev/null || true
    fi
    
    # Arr√™ter les processus npm qui pourraient encore tourner
    pkill -f "npm run" 2>/dev/null || true
    pkill -f "vite" 2>/dev/null || true
    pkill -f "nest start" 2>/dev/null || true
    
    sleep 2
    print_success "${SUCCESS_EMOJI} Tous les services ont √©t√© arr√™t√©s"
    exit 0
}

# Intercepter Ctrl+C
trap cleanup SIGINT SIGTERM

# Fonction de v√©rification des d√©pendances
check_dependencies() {
    print_status "üîç V√©rification des d√©pendances..."
    
    # V√©rifier Node.js
    if ! command -v node &> /dev/null; then
        print_error "Node.js n'est pas install√©"
        exit 1
    fi
    
    # V√©rifier npm
    if ! command -v npm &> /dev/null; then
        print_error "npm n'est pas install√©"
        exit 1
    fi
    
    # V√©rifier la structure du projet
    if [ ! -d "AREA-Project" ]; then
        print_error "Structure du projet AREA-Project non trouv√©e"
        exit 1
    fi
    
    print_success "‚úì D√©pendances valid√©es"
}

# Fonction de v√©rification des ports
check_ports() {
    print_status "üîç V√©rification de la disponibilit√© des ports..."
    
    local ports_busy=()
    
    # V√©rifier port 5001 (Backend)
    if nc -z localhost 5001 2>/dev/null; then
        ports_busy+=("5001 (Backend)")
    fi
    
    # V√©rifier port 3000 (Frontend)
    if nc -z localhost 3000 2>/dev/null; then
        ports_busy+=("3000 (Frontend)")
    fi
    
    # V√©rifier port 5175 (Mobile)
    if nc -z localhost 5175 2>/dev/null; then
        ports_busy+=("5175 (Mobile)")
    fi
    
    if [ ${#ports_busy[@]} -gt 0 ]; then
        print_warning "‚ö†Ô∏è Ports occup√©s d√©tect√©s:"
        for port in "${ports_busy[@]}"; do
            echo "   - $port"
        done
        echo ""
        
        # Mode automatique si variable d'environnement AUTO_KILL_PORTS est d√©finie ou argument --auto
        if [[ "$AUTO_MODE" == "true" ]] || [[ "$AUTO_KILL_PORTS" == "true" ]]; then
            print_status "üßπ Lib√©ration automatique des ports..."
            sudo fuser -k 5001/tcp 2>/dev/null || true
            sudo fuser -k 3000/tcp 2>/dev/null || true  
            sudo fuser -k 5175/tcp 2>/dev/null || true
            sleep 2
            print_success "‚úì Ports lib√©r√©s automatiquement"
        else
            read -p "Voulez-vous lib√©rer ces ports automatiquement ? (y/N): " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                print_status "üßπ Lib√©ration des ports..."
                sudo fuser -k 5001/tcp 2>/dev/null || true
                sudo fuser -k 3000/tcp 2>/dev/null || true  
                sudo fuser -k 5175/tcp 2>/dev/null || true
                sleep 2
                print_success "‚úì Ports lib√©r√©s"
            else
                print_error "Impossible de continuer avec des ports occup√©s"
                exit 1
            fi
        fi
    else
        print_success "‚úì Tous les ports sont disponibles"
    fi
}

# Fonction de v√©rification et correction Prisma
check_prisma_setup() {
    print_status "üîç V√©rification de la configuration Prisma..."
    
    if [ -f "AREA-Project/back/prisma/schema.prisma" ]; then
        # V√©rifier si les binaryTargets sont configur√©s
        if ! grep -q "binaryTargets" "AREA-Project/back/prisma/schema.prisma"; then
            print_warning "‚ö†Ô∏è Binary targets Prisma manquants (correction automatique)"
            
            # Backup du schema
            cp "AREA-Project/back/prisma/schema.prisma" "AREA-Project/back/prisma/schema.prisma.backup"
            
            # Corriger le schema.prisma
            sed -i 's/provider = "prisma-client-js"/provider      = "prisma-client-js"\n  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]/' "AREA-Project/back/prisma/schema.prisma"
            
            # R√©g√©n√©rer le client
            print_status "üîÑ R√©g√©n√©ration du client Prisma..."
            cd AREA-Project/back && npx prisma generate --silent > /dev/null 2>&1 && cd ../..
            
            print_success "‚úì Configuration Prisma corrig√©e"
        else
            print_success "‚úì Configuration Prisma valide"
        fi
    else
        print_warning "‚ö†Ô∏è Schema Prisma non trouv√©"
    fi
}

# Fonction d'installation des d√©pendances
install_dependencies() {
    print_status "üì¶ V√©rification des d√©pendances npm..."
    
    local needs_install=false
    
    # V√©rifier backend
    if [ ! -d "AREA-Project/back/node_modules" ] || [ -z "$(ls -A AREA-Project/back/node_modules 2>/dev/null)" ]; then
        needs_install=true
        print_warning "Dependencies backend manquantes"
    fi
    
    # V√©rifier frontend
    if [ ! -d "AREA-Project/front/node_modules" ] || [ -z "$(ls -A AREA-Project/front/node_modules 2>/dev/null)" ]; then
        needs_install=true
        print_warning "Dependencies frontend manquantes"
    fi
    
    # V√©rifier mobile
    if [ ! -d "AREA-Project/mobile/node_modules" ] || [ -z "$(ls -A AREA-Project/mobile/node_modules 2>/dev/null)" ]; then
        needs_install=true
        print_warning "Dependencies mobile manquantes"
    fi
    
    if [ "$needs_install" = true ]; then
        print_status "üîß Installation des d√©pendances manquantes..."
        
        # Installation backend
        if [ ! -d "AREA-Project/back/node_modules" ] || [ -z "$(ls -A AREA-Project/back/node_modules 2>/dev/null)" ]; then
            print_service "${BACKEND_EMOJI} Installation backend..."
            cd AREA-Project/back && npm install --silent > /dev/null 2>&1 && cd ../..
            print_success "‚úì Backend install√©"
        fi
        
        # Installation frontend  
        if [ ! -d "AREA-Project/front/node_modules" ] || [ -z "$(ls -A AREA-Project/front/node_modules 2>/dev/null)" ]; then
            print_service "${FRONTEND_EMOJI} Installation frontend..."
            cd AREA-Project/front && npm install && cd ../..
            print_success "‚úì Frontend install√©"
        fi
        
        # Installation mobile
        if [ ! -d "AREA-Project/mobile/node_modules" ] || [ -z "$(ls -A AREA-Project/mobile/node_modules 2>/dev/null)" ]; then
            print_service "${MOBILE_EMOJI} Installation mobile..."
            cd AREA-Project/mobile && npm install && cd ../..
            print_success "‚úì Mobile install√©"
        fi
    else
        print_success "‚úì Toutes les d√©pendances sont pr√©sentes"
    fi
    
    # V√©rifier la configuration Prisma apr√®s l'installation
    check_prisma_setup
}

# Fonction de d√©marrage d'un service
start_service() {
    local service_name="$1"
    local service_dir="$2"
    local service_command="$3"
    local service_emoji="$4"
    local expected_port="$5"
    
    print_service "${service_emoji} D√©marrage de $service_name..."
    
    # S'assurer qu'on est dans le bon r√©pertoire
    local current_dir=$(pwd)
    local service_path="$current_dir/AREA-Project/$service_dir"
    
    if [ ! -d "$service_path" ]; then
        print_error "‚ùå R√©pertoire service non trouv√©: $service_path"
        return 1
    fi
    
    # Cr√©er un fichier de log temporaire
    local log_file="/tmp/area_${service_name,,}_$(date +%s).log"
    
    # D√©marrer le processus avec nohup pour plus de stabilit√©
    cd "$service_path"
    nohup bash -c "$service_command" > "$log_file" 2>&1 &
    local pid=$!
    
    # Retourner au r√©pertoire racine
    cd "$current_dir"
    
    # Attendre que le service d√©marre (timeout plus long pour les services lents)
    local max_attempts=60  # Augment√© de 30 √† 60 secondes
    local attempt=0
    
    print_status "‚è≥ Attente du d√©marrage de $service_name..."
    
    while [ $attempt -lt $max_attempts ]; do
        if nc -z localhost "$expected_port" 2>/dev/null; then
            print_success "‚úì $service_name pr√™t sur le port $expected_port"
            echo "$pid"
            return 0
        fi
        
        # V√©rifier si le processus est encore en vie
        if ! kill -0 "$pid" 2>/dev/null; then
            print_error "‚ùå $service_name a √©chou√© au d√©marrage"
            print_error "Voir le log: $log_file"
            if [ -f "$log_file" ]; then
                print_error "Derni√®res lignes du log:"
                tail -5 "$log_file" | while read line; do print_error "  $line"; done
            fi
            return 1
        fi
        
        sleep 2  # Attendre 2 secondes au lieu de 1
        attempt=$((attempt + 2))
        
        # Afficher un point de progression
        if [ $((attempt % 10)) -eq 0 ]; then
            print_status "‚è≥ $service_name en cours de d√©marrage... (${attempt}s/${max_attempts}s)"
        fi
    done
    
    print_error "‚ùå Timeout: $service_name n'a pas d√©marr√© apr√®s ${max_attempts}s"
    if [ -f "$log_file" ]; then
        print_error "Voir le log: $log_file"
        print_error "Derni√®res lignes:"
        tail -10 "$log_file" | while read line; do print_error "  $line"; done
    fi
    return 1
}

# Fonction principale de d√©marrage
start_all_services() {
    print_status "üöÄ D√©marrage de tous les services..."
    echo ""
    
    # D√©marrer le backend
    BACKEND_PID=$(start_service "Backend" "back" "npm run start:dev" "$BACKEND_EMOJI" "5001")
    if [ $? -ne 0 ]; then
        print_error "Impossible de d√©marrer le backend"
        cleanup
        exit 1
    fi
    
    # D√©marrer le frontend
    FRONTEND_PID=$(start_service "Frontend" "front" "npm run dev" "$FRONTEND_EMOJI" "3000")
    if [ $? -ne 0 ]; then
        print_error "Impossible de d√©marrer le frontend"
        cleanup
        exit 1
    fi
    
    # D√©marrer le mobile
    MOBILE_PID=$(start_service "Mobile" "mobile" "npm run dev" "$MOBILE_EMOJI" "5175")
    if [ $? -ne 0 ]; then
        print_error "Impossible de d√©marrer le mobile"
        cleanup
        exit 1
    fi
    
    echo ""
    print_success "${SUCCESS_EMOJI} Tous les services sont d√©marr√©s avec succ√®s !"
}

# Fonction d'affichage du statut final
show_final_status() {
    echo ""
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë                     üéâ SERVICES ACTIFS                      ‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo -e "${BACKEND_EMOJI} ${GREEN}Backend NestJS${NC}    : http://localhost:5001"
    echo -e "${FRONTEND_EMOJI} ${GREEN}Frontend React${NC}    : http://localhost:3000"
    echo -e "${MOBILE_EMOJI} ${GREEN}Mobile Ionic${NC}      : http://localhost:5175"
    echo ""
    echo -e "${INFO_EMOJI} ${BLUE}API Health${NC}        : http://localhost:5001/mobile/health"
    echo -e "${INFO_EMOJI} ${BLUE}API CORS Test${NC}     : http://localhost:5001/mobile/cors-test"
    echo ""
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë                      üìã INSTRUCTIONS                        ‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo "üß™ Tests sugg√©r√©s :"
    echo "   1. Frontend Web    ‚Üí http://localhost:3000"
    echo "   2. Mobile App      ‚Üí http://localhost:5175"
    echo "   3. API Health      ‚Üí http://localhost:5001/mobile/health"
    echo "   4. Test Auth       ‚Üí Inscription/Connexion sur mobile"
    echo "   5. Google OAuth    ‚Üí Test SSO sur les deux apps"
    echo ""
    echo -e "${YELLOW}‚ö†Ô∏è  Pour arr√™ter tous les services : Ctrl+C${NC}"
    echo ""
}

# Fonction de surveillance des services
monitor_services() {
    print_status "üîç Surveillance des services en cours..."
    print_status "Appuyez sur Ctrl+C pour arr√™ter tous les services"
    
    while true; do
        sleep 10
        
        # V√©rifier si tous les services sont encore actifs via les ports
        local services_down=()
        
        if ! nc -z localhost 5001 2>/dev/null; then
            services_down+=("Backend")
        fi
        
        if ! nc -z localhost 3000 2>/dev/null; then
            services_down+=("Frontend")
        fi
        
        if ! nc -z localhost 5175 2>/dev/null; then
            services_down+=("Mobile")
        fi
        
        if [ ${#services_down[@]} -gt 0 ]; then
            print_error "‚ùå Services arr√™t√©s inopin√©ment : ${services_down[*]}"
            cleanup
            exit 1
        fi
        
        # Affichage p√©riodique du statut
        if [ $(($(date +%s) % 60)) -eq 0 ]; then
            print_status "‚úì Tous les services fonctionnent correctement"
        fi
    done
}

# PROGRAMME PRINCIPAL
main() {
    print_header
    
    # V√©rifications pr√©liminaires
    check_dependencies
    check_ports
    install_dependencies
    
    echo ""
    print_status "üéØ Mode: $MODE"
    
    case "$MODE" in
        "dev"|"")
            start_all_services
            if [ $? -eq 0 ]; then
                show_final_status
                echo ""
                print_status "üîç Services d√©marr√©s ! Appuyez sur Ctrl+C pour arr√™ter."
                # Boucle simple d'attente
                while true; do
                    sleep 30
                    # V√©rification p√©riodique simple
                    if ! nc -z localhost 5001 2>/dev/null; then
                        print_error "‚ùå Backend arr√™t√©"
                        cleanup
                        exit 1
                    fi
                done
            else
                print_error "‚ùå Erreur lors du d√©marrage des services"
                cleanup
                exit 1
            fi
            ;;
        "clean")
            print_status "üßπ Nettoyage des caches et node_modules..."
            rm -rf AREA-Project/*/node_modules 2>/dev/null || true
            rm -rf AREA-Project/*/dist 2>/dev/null || true
            rm -rf AREA-Project/*/.vite 2>/dev/null || true
            print_success "‚úì Nettoyage termin√©"
            ;;
        "docker")
            print_status "üê≥ Mode Docker non impl√©ment√© dans cette version"
            print_warning "Utilisez: ./dev.sh start"
            ;;
        *)
            print_error "Mode '$MODE' non reconnu"
            echo "Modes disponibles: dev, clean, docker"
            exit 1
            ;;
    esac
}

# Lancement du programme principal
main "$@"